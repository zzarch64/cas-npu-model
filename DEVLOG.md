# ECHO NPU Extension å¼€å‘æ—¥å¿—

## é¡¹ç›®æ¦‚è¿°

æœ¬é¡¹ç›®æ—¨åœ¨ä¸º PyTorch æä¾› ECHO NPU åç«¯æ”¯æŒï¼Œå®ç°æ ¸å¿ƒç®—å­ä»¥æ”¯æŒæ·±åº¦å­¦ä¹ æ¨¡å‹ï¼ˆç‰¹åˆ«æ˜¯ LLMï¼‰åœ¨ NPU ä¸Šçš„è¿è¡Œã€‚

---

## å¼€å‘æ€è·¯

### æ ¸å¿ƒç­–ç•¥ï¼šå…ˆè·‘é€šï¼Œå†ä¼˜åŒ–

é‡‡ç”¨**æ¸è¿›å¼å¼€å‘**ç­–ç•¥ï¼Œåˆ†ä¸ºä¸¤ä¸ªä¸»è¦é˜¶æ®µï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µä¸€ï¼šåŠŸèƒ½éªŒè¯ï¼ˆFallback æ¨¡å¼ï¼‰                                        â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                                        â”‚
â”‚  ç›®æ ‡ï¼šè®©æ¨¡å‹å®Œæ•´è·‘èµ·æ¥ï¼ŒéªŒè¯æ¡†æ¶æ­£ç¡®æ€§                                    â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ PyTorch  â”‚â”€â”€â”€â–¶â”‚ Deviceâ†’  â”‚â”€â”€â”€â–¶â”‚ CPU è®¡ç®— â”‚â”€â”€â”€â–¶â”‚ â†’Device  â”‚          â”‚
â”‚  â”‚ ç®—å­è°ƒç”¨  â”‚    â”‚ CPU æ‹·è´ â”‚    â”‚ (ç°æˆå®ç°)â”‚    â”‚ æ‹·è´å›   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  âœ“ å¿«é€Ÿå®ç°æ‰€æœ‰ç®—å­    âœ“ éªŒè¯æ¨¡å‹æ­£ç¡®æ€§    âœ“ å»ºç«‹æµ‹è¯•åŸºå‡†               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é˜¶æ®µäºŒï¼šæ€§èƒ½ä¼˜åŒ–ï¼ˆNPU åŸç”Ÿå®ç°ï¼‰                                         â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                                        â”‚
â”‚  ç›®æ ‡ï¼šé€ä¸ªæ›¿æ¢ä¸º NPU åŸç”Ÿç®—å­ï¼Œæå‡æ€§èƒ½                                   â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ PyTorch  â”‚â”€â”€â”€â–¶â”‚ NPU Runtime API ç›´æ¥æ‰§è¡Œ        â”‚                   â”‚
â”‚  â”‚ ç®—å­è°ƒç”¨  â”‚    â”‚ (æ—  CPU å¾€è¿”ï¼Œæœ€ä¼˜æ€§èƒ½)          â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                                                                         â”‚
â”‚  âœ“ æ¶ˆé™¤å†…å­˜æ‹·è´    âœ“ å……åˆ†åˆ©ç”¨ NPU ç®—åŠ›    âœ“ è¾¾åˆ°ç”Ÿäº§æ€§èƒ½                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ä¸ºä»€ä¹ˆé‡‡ç”¨è¿™ç§ç­–ç•¥ï¼Ÿ

| ä¼˜åŠ¿ | è¯´æ˜ |
|-----|------|
| **é™ä½å¼€å‘é£é™©** | å…ˆç”¨æˆç†Ÿçš„ CPU å®ç°éªŒè¯æ•´ä½“æ¡†æ¶ï¼Œé¿å…åŒæ—¶è°ƒè¯•æ¡†æ¶å’Œç®—å­ |
| **å¿«é€Ÿè¿­ä»£** | Fallback æ¨¡å¼ä¸‹å¯ä»¥å¿«é€Ÿæ”¯æŒæ–°ç®—å­ï¼Œè®©æ¨¡å‹è·‘èµ·æ¥ |
| **æ˜ç¡®ä¼˜åŒ–æ–¹å‘** | é€šè¿‡ profiling ç¡®å®šæ€§èƒ½ç“¶é¢ˆï¼ŒæŒ‰ä¼˜å…ˆçº§ä¼˜åŒ–æœ€å…³é”®çš„ç®—å­ |
| **ä¿æŒå¯æµ‹è¯•æ€§** | Fallback å®ç°ä½œä¸ºå‚è€ƒï¼Œå¯ç”¨äºéªŒè¯ NPU åŸç”Ÿå®ç°çš„æ­£ç¡®æ€§ |

### å…·ä½“è¿­ä»£æ­¥éª¤

```
1. æ–°ç®—å­éœ€æ±‚ â”€â”€â–¶ 2. å®ç° Fallback ç‰ˆæœ¬ â”€â”€â–¶ 3. æ¨¡å‹æµ‹è¯•é€šè¿‡
                        â”‚
                        â–¼
4. æ€§èƒ½åˆ†æ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
5. é«˜é¢‘ç®—å­ä¼˜å…ˆå®ç° NPU åŸç”Ÿç‰ˆæœ¬
      â”‚
      â–¼
6. å¯¹æ¯” Fallback éªŒè¯æ­£ç¡®æ€§ â”€â”€â–¶ 7. æ›¿æ¢ä¸ºåŸç”Ÿå®ç°
```

### å½“å‰çŠ¶æ€

- âœ… **é˜¶æ®µä¸€åŸºæœ¬å®Œæˆ**ï¼šQwen 0.5B æ¨¡å‹å·²èƒ½å®Œæ•´è¿è¡Œ
- â³ **é˜¶æ®µäºŒè¿›è¡Œä¸­**ï¼šå·²å®ç° `mm`ã€`bmm`ã€`add.Tensor` çš„ NPU åŸç”Ÿç‰ˆæœ¬
- ğŸ“‹ **ä¸‹ä¸€æ­¥**ï¼šæŒ‰ä¼˜å…ˆçº§å®ç° RMSNorm ç›¸å…³ç®—å­ï¼ˆrsqrt, mul, pow, meanï¼‰

---

## Fallback æ–¹æ¡ˆçš„æ€§èƒ½ä»£ä»·åˆ†æ

### ä¸ºä»€ä¹ˆ Fallback æ–¹æ¡ˆæ€§èƒ½å·®ï¼Ÿ

æ¯æ¬¡ `cpu_fallback` æ‰§è¡Œéƒ½ä¼šäº§ç”Ÿå¤§é‡çš„å†…å­˜åˆ†é…å’Œé‡Šæ”¾æ“ä½œï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  cpu_fallback æ‰§è¡Œå•ä¸ªç®—å­ï¼ˆå¦‚ rsqrt(x)ï¼‰                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  1. è¾“å…¥å‡†å¤‡                                                â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚     â”‚ CPU malloc   â”‚ â† ä¸º x_cpu åˆ†é… CPU å†…å­˜               â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚     â”‚ echoNpuMemcpy â”‚ â† Dâ†’H æ‹·è´æ•°æ®                         â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â”‚                                                             â”‚
â”‚  2. CPU è®¡ç®—                                                â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚     â”‚ CPU malloc   â”‚ â† ä¸º result_cpu åˆ†é… CPU å†…å­˜          â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â”‚     rsqrt(x_cpu) â†’ result_cpu                               â”‚
â”‚                                                             â”‚
â”‚  3. è¾“å‡ºä¼ å›                                                â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚     â”‚ echoNpuMalloc â”‚ â† ä¸º result_npu åˆ†é… NPU å†…å­˜          â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚     â”‚ echoNpuMemcpy â”‚ â† Hâ†’D æ‹·è´æ•°æ®                         â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â”‚                                                             â”‚
â”‚  4. æ¸…ç†ï¼ˆå‡½æ•°è¿”å›åï¼Œå¼•ç”¨è®¡æ•°å½’é›¶æ—¶ï¼‰                         â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚     â”‚ CPU free     â”‚ â† x_cpuã€result_cpu é‡Šæ”¾               â”‚
â”‚     â”‚ echoNpuFree   â”‚ â† æ—§ NPU tensor é‡Šæ”¾ï¼ˆå¦‚æœè¢«è¦†ç›–ï¼‰       â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è®¡ç®—é“¾çš„å†…å­˜æ“ä½œç´¯ç§¯

ä»¥ `y = (x * 2 + 1).rsqrt()` ä¸ºä¾‹ï¼š

| æ“ä½œ | CPU malloc | CPU free | NPU malloc | NPU free |
|-----|-----------|----------|-----------|----------|
| `x * 2` | 2 | 2 | 1 | 0 |
| `... + 1` | 2 | 2 | 1 | 1* |
| `.rsqrt()` | 2 | 2 | 1 | 1* |
| **æ€»è®¡** | **6** | **6** | **3** | **2** |

*ä¸­é—´ç»“æœè¢«ä¸‹ä¸€æ­¥è¦†ç›–æ—¶é‡Šæ”¾

### æ€§èƒ½å¼€é”€ç»„æˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Fallback å¼€é”€ç»„æˆ                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. æ•°æ®ä¼ è¾“å»¶è¿Ÿ     â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚ æœ€å¤§å¼€é”€     â”‚
â”‚  2. malloc/free å¼€é”€ â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â”‚ æ˜¾è‘—å¼€é”€     â”‚
â”‚  3. å†…å­˜ç¢ç‰‡åŒ–       â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â”‚ ç´¯ç§¯å½±å“     â”‚
â”‚  4. CPU è®¡ç®—æœ¬èº«     â”‚â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â”‚ ç›¸å¯¹è¾ƒå°     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### NPU åŸç”Ÿå®ç° vs Fallback å¯¹æ¯”

| æ–¹æ¡ˆ | malloc æ¬¡æ•° | free æ¬¡æ•° | memcpy æ¬¡æ•° |
|-----|------------|----------|------------|
| **NPU åŸç”Ÿ** | 1 (ä»…è¾“å‡º) | 0 | 0 |
| **Fallback** | 2-3 | 2 | 2 (Dâ†’H + Hâ†’D) |

### ç»“è®º

1. **æ€§èƒ½å·®è·å·¨å¤§**ï¼šFallback å¯èƒ½æ¯”åŸç”Ÿå®ç°æ…¢ 10-100 å€
2. **å†…å­˜å³°å€¼é«˜**ï¼šä¸´æ—¶ tensor ä¼šå¢åŠ å†…å­˜å ç”¨å³°å€¼
3. **GC å‹åŠ›å¤§**ï¼šé¢‘ç¹åˆ†é…/é‡Šæ”¾ç»™å†…å­˜ç®¡ç†å¸¦æ¥å‹åŠ›

**å¼€å‘è·¯çº¿æ­£ç¡®æ€§**ï¼šå…ˆç”¨ Fallback è·‘é€šåŠŸèƒ½éªŒè¯æ­£ç¡®æ€§ï¼Œå†é€æ­¥æ›¿æ¢ä¸º NPU åŸç”Ÿå®ç°æ˜¯åˆç†çš„æ¸è¿›ç­–ç•¥ã€‚

---

## æ¶æ„è®¾è®¡

### å†…å­˜æ¨¡å‹ï¼šæ˜¾å¼ Copy æ¨¡å¼

é‡‡ç”¨ç±»ä¼¼ CUDA GPU çš„ç‹¬ç«‹å†…å­˜æ¶æ„ï¼Œè®¾å¤‡å†…å­˜å’Œ CPU å†…å­˜ä¸å…±äº«ï¼Œéœ€è¦æ˜¾å¼è¿›è¡Œæ•°æ®æ‹·è´ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Host (CPU) Memory                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
         echoNpuMemcpy(HOST_TO_DEVICE) â†“ â†‘ echoNpuMemcpy(DEVICE_TO_HOST)
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Device (NPU) Memory                       â”‚
â”‚                                                              â”‚
â”‚   echoNpuMalloc() åˆ†é…    echoNpuFree() é‡Šæ”¾                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å†…å­˜æ‹·è´æ–¹å‘ï¼ˆç±»ä¼¼ cudaMemcpyKindï¼‰

```cpp
enum EchoNpuMemcpyKind {
    ECHO_NPU_MEMCPY_HOST_TO_HOST = 0,      // CPU -> CPU
    ECHO_NPU_MEMCPY_HOST_TO_DEVICE = 1,    // CPU -> Device
    ECHO_NPU_MEMCPY_DEVICE_TO_HOST = 2,    // Device -> CPU
    ECHO_NPU_MEMCPY_DEVICE_TO_DEVICE = 3,  // Device -> Device
    ECHO_NPU_MEMCPY_DEFAULT = 4            // è‡ªåŠ¨æ£€æµ‹
};
```

### ç®—å­å®ç°ç­–ç•¥

| å®ç°æ–¹å¼ | æè¿° | æ€§èƒ½ | é€‚ç”¨åœºæ™¯ |
|---------|------|------|---------|
| **NPU åŸç”Ÿå®ç°** | ç›´æ¥åœ¨ NPU ä¸Šæ‰§è¡Œï¼Œæ— å†…å­˜æ‹·è´ | â­â­â­ æœ€ä¼˜ | é«˜é¢‘ç®—å­ï¼ˆmm, bmm, addï¼‰ |
| **CPU Fallback** | é€šè¿‡ `cpu_fallback` è‡ªåŠ¨å¤„ç† | â­ è¾ƒæ…¢ | å¼€å‘é˜¶æ®µä¸´æ—¶æ–¹æ¡ˆ |
| **View æ“ä½œ** | ä»…ä¿®æ”¹ metadataï¼Œæ— æ•°æ®æ‹·è´ | â­â­â­ æœ€ä¼˜ | reshape, transpose, slice ç­‰ |

### ä»£ç æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PyTorch ç®—å­å±‚ (backend/echo_npu_ops.cpp)                    â”‚
â”‚  - NPU åŸç”Ÿå®ç°ï¼šç›´æ¥è°ƒç”¨ Runtime API                         â”‚
â”‚  - CPU Fallbackï¼šé€šè¿‡ at::native::cpu_fallback è‡ªåŠ¨å¤„ç†      â”‚
â”‚  - View æ“ä½œï¼šä»…ä¿®æ”¹ tensor metadata                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  NPU Runtime API (runtime/echo_npu_runtime.h)                â”‚
â”‚  - å†…å­˜ç®¡ç†ï¼šechoNpuMalloc, echoNpuFree, echoNpuMemcpy         â”‚
â”‚  - è®¡ç®—ç®—å­ï¼šechoNpuMatMul, echoNpuAddTensor, ...             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç¡¬ä»¶å®ç°å±‚                                                  â”‚
â”‚  - runtime/cmodel/   : CPU æ¨¡æ‹Ÿå®ç°ï¼ˆå¼€å‘è°ƒè¯•ç”¨ï¼‰            â”‚
â”‚  - runtime/fpga/     : FPGA ç¡¬ä»¶å®ç°                        â”‚
â”‚  - runtime/asic/     : æœªæ¥ ASIC èŠ¯ç‰‡å®ç°                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Qwen 0.5B æ¨ç†ç®—å­è¿›åº¦è¡¨

### ğŸ“Š æ€»ä½“è¿›åº¦

| ç±»åˆ« | NPUåŸç”Ÿå®ç° | CPU Fallback | Viewæ“ä½œ | æ€»è®¡ |
|-----|------------|--------------|---------|------|
| æ•°é‡ | 3 | 17 | 13 | 33 |
| çŠ¶æ€ | âœ… å·²å®Œæˆ | âš ï¸ ä¸´æ—¶æ–¹æ¡ˆ | âœ… å·²å®Œæˆ | - |

### âœ… NPU åŸç”Ÿå®ç°ï¼ˆé«˜æ€§èƒ½ï¼‰

è¿™äº›ç®—å­ç›´æ¥åœ¨ NPU ä¸Šæ‰§è¡Œï¼Œæ— éœ€ CPU å¾€è¿”ï¼Œæ˜¯æ€§èƒ½å…³é”®è·¯å¾„ã€‚

| ç®—å­ | Runtime API | ç”¨é€” | çŠ¶æ€ |
|-----|-------------|------|------|
| `mm` | `echoNpuMatMul` | Linear å±‚ã€æŠ•å½±å±‚ | âœ… å·²å®ç° |
| `bmm` | `echoNpuBatchMatMul` | Attention (Q@K^T, scores@V) | âœ… å·²å®ç° |
| `add.Tensor` | `echoNpuAddTensor` | æ®‹å·®è¿æ¥ã€åç½®åŠ æ³• | âœ… å·²å®ç° |

### âš ï¸ CPU Fallback å®ç°ï¼ˆéœ€ä¼˜åŒ–ä¸º NPU åŸç”Ÿï¼‰

è¿™äº›ç®—å­å½“å‰ä½¿ç”¨ç»Ÿä¸€çš„ `cpu_fallback` æœºåˆ¶ï¼ŒPyTorch è‡ªåŠ¨å¤„ç† Deviceâ†”CPU æ•°æ®ä¼ è¾“ã€‚

#### RMSNorm ç›¸å…³ï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰
| ç®—å­ | å¾…å®ç° Runtime API | ç”¨é€” | è°ƒç”¨é¢‘ç‡ |
|-----|-------------------|------|---------|
| `rsqrt` | `echoNpuRsqrt` | 1/sqrt(x)ï¼ŒRMSNorm æ ¸å¿ƒ | æ¯å±‚ 2 æ¬¡ |
| `pow.Tensor_Scalar` | `echoNpuPow` | x^2ï¼Œè®¡ç®—æ–¹å·® | æ¯å±‚ 2 æ¬¡ |
| `mean.dim` | `echoNpuMean` | ç»´åº¦å‡å€¼ | æ¯å±‚ 2 æ¬¡ |

#### Rotary Embedding ç›¸å…³ï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰
| ç®—å­ | å¾…å®ç° Runtime API | ç”¨é€” | è°ƒç”¨é¢‘ç‡ |
|-----|-------------------|------|---------|
| `cos` | `echoNpuCos` | ä½ç½®ç¼–ç  | æ¯å±‚ 1 æ¬¡ |
| `sin` | `echoNpuSin` | ä½ç½®ç¼–ç  | æ¯å±‚ 1 æ¬¡ |

#### åŸºç¡€æ•°å­¦è¿ç®—ï¼ˆä¸­ä¼˜å…ˆçº§ï¼‰
| ç®—å­ | å¾…å®ç° Runtime API | ç”¨é€” | è°ƒç”¨é¢‘ç‡ |
|-----|-------------------|------|---------|
| `mul.Tensor` | `echoNpuMulTensor` | é€å…ƒç´ ä¹˜æ³• | é«˜ |
| `mul.Scalar` | `echoNpuMulScalar` | æ ‡é‡ä¹˜æ³• | é«˜ |
| `add.Scalar` | `echoNpuAddScalar` | æ ‡é‡åŠ æ³• | ä¸­ |
| `sub.Tensor` | `echoNpuSubTensor` | å‡æ³• | ä½ |
| `div.Tensor` | `echoNpuDivTensor` | é™¤æ³• | ä½ |
| `neg` | `echoNpuNeg` | å–è´Ÿ | ä½ |
| `sqrt` | `echoNpuSqrt` | å¹³æ–¹æ ¹ | ä½ |

#### æ¿€æ´»å‡½æ•°ï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰
| ç®—å­ | å¾…å®ç° Runtime API | ç”¨é€” | è°ƒç”¨é¢‘ç‡ |
|-----|-------------------|------|---------|
| `silu` | `echoNpuSiLU` | SiLU æ¿€æ´» (FFN) | æ¯å±‚ 1 æ¬¡ |

#### Attention ç›¸å…³ï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰
| ç®—å­ | å¾…å®ç° Runtime API | ç”¨é€” | è°ƒç”¨é¢‘ç‡ |
|-----|-------------------|------|---------|
| `softmax.int` | `echoNpuSoftmax` | Attention å½’ä¸€åŒ– | æ¯å±‚ 1 æ¬¡ |
| `scaled_dot_product_attention` | `echoNpuSDPA` | èåˆ Attention | æ¯å±‚ 1 æ¬¡ |

#### å…¶ä»–ï¼ˆä½ä¼˜å…ˆçº§ï¼‰
| ç®—å­ | å¾…å®ç° Runtime API | ç”¨é€” | è°ƒç”¨é¢‘ç‡ |
|-----|-------------------|------|---------|
| `embedding` | `echoNpuEmbedding` | Token åµŒå…¥ | ä»…è¾“å…¥å±‚ |
| `cat` | `echoNpuCat` | KV Cache æ‹¼æ¥ | æ¯å±‚ 2 æ¬¡ |
| `clone` | `echoNpuClone` | å¼ é‡å¤åˆ¶ | ä½ |
| `contiguous` | `echoNpuContiguous` | å†…å­˜è¿ç»­åŒ– | ä½ |

### âœ… View æ“ä½œï¼ˆæ— éœ€ä¼˜åŒ–ï¼‰

è¿™äº›æ“ä½œä»…ä¿®æ”¹ tensor çš„ metadataï¼ˆshape, stride, offsetï¼‰ï¼Œä¸æ¶‰åŠæ•°æ®æ‹·è´ï¼Œå·²æ˜¯æœ€ä¼˜å®ç°ã€‚

| ç®—å­ | ç”¨é€” | çŠ¶æ€ |
|-----|------|------|
| `view` | æ”¹å˜å½¢çŠ¶ | âœ… åŸç”Ÿå®ç° |
| `reshape` | æ”¹å˜å½¢çŠ¶ | âœ… åŸç”Ÿå®ç° |
| `transpose.int` | äº¤æ¢ç»´åº¦ | âœ… åŸç”Ÿå®ç° |
| `permute` | é‡æ’ç»´åº¦ | âœ… åŸç”Ÿå®ç° |
| `unsqueeze` | æ’å…¥ç»´åº¦ | âœ… åŸç”Ÿå®ç° |
| `squeeze` / `squeeze.dim` | ç§»é™¤ç»´åº¦ | âœ… åŸç”Ÿå®ç° |
| `expand` | å¹¿æ’­æ‰©å±• | âœ… åŸç”Ÿå®ç° |
| `slice.Tensor` | åˆ‡ç‰‡ | âœ… åŸç”Ÿå®ç° |
| `select.int` | é€‰æ‹©ç´¢å¼• | âœ… åŸç”Ÿå®ç° |
| `as_strided` | è‡ªå®šä¹‰ stride | âœ… åŸç”Ÿå®ç° |
| `t` | 2D è½¬ç½® | âœ… åŸç”Ÿå®ç° |
| `detach` | åˆ†ç¦»æ¢¯åº¦ | âœ… åŸç”Ÿå®ç° |
| `_reshape_alias` | reshape åˆ«å | âœ… åŸç”Ÿå®ç° |

---

## ç‰¹æ®Šç®—å­å¤„ç†è¯´æ˜

### `contiguous` - ä¿ç•™è‡ªå®šä¹‰å®ç°

`contiguous()` ä¿ç•™äº†è‡ªå®šä¹‰å®ç°è€Œéä½¿ç”¨ `cpu_fallback`ï¼ŒåŸå› æ˜¯å¯ä»¥ä¼˜åŒ–"å·²ç»è¿ç»­"çš„å¸¸è§æƒ…å†µï¼š

```cpp
at::Tensor echo_npu_contiguous(const at::Tensor& self, at::MemoryFormat memory_format) {
    // å¦‚æœå·²ç»æ˜¯ contiguous çš„ï¼Œç›´æ¥è¿”å›ï¼ˆé›¶å¼€é”€ï¼‰
    if (self.is_contiguous(memory_format)) {
        return self;  // â† æ— éœ€ä»»ä½•æ‹·è´ï¼
    }
    
    // çœŸæ­£éœ€è¦è¿ç»­åŒ–æ—¶ï¼Œæ‰èµ° fallback è·¯å¾„
    at::Tensor self_cpu = device_to_cpu(self);
    at::Tensor contiguous_cpu = self_cpu.contiguous(memory_format);
    return cpu_to_device(contiguous_cpu, self.device());
}
```

| å®ç°æ–¹å¼ | å·²è¿ç»­æ—¶ | éè¿ç»­æ—¶ |
|---------|---------|---------|
| `cpu_fallback` | Dâ†’Hâ†’Dï¼ˆæµªè´¹ï¼‰ | Dâ†’Hâ†’D |
| è‡ªå®šä¹‰å®ç° | ç›´æ¥è¿”å›ï¼ˆé›¶å¼€é”€ï¼‰âœ“ | Dâ†’Hâ†’D |

åœ¨æ·±åº¦å­¦ä¹ æ¨¡å‹ä¸­ï¼Œ90%+ çš„ `contiguous()` è°ƒç”¨æ—¶ tensor å·²ç»æ˜¯è¿ç»­çš„ï¼Œè‡ªå®šä¹‰å®ç°å¯é¿å…å¤§é‡æ— è°“æ‹·è´ã€‚

---

## å¼€å‘ä¼˜å…ˆçº§

### ğŸ”´ P0: æ€§èƒ½å…³é”®ï¼ˆæ¯å±‚å¤šæ¬¡è°ƒç”¨ï¼‰

**ç›®æ ‡ï¼šæ¶ˆé™¤æœ€é«˜é¢‘çš„ CPU å¾€è¿”**

| ç®—å­ | é¢„æœŸæ€§èƒ½æå‡ | å¤æ‚åº¦ |
|-----|-------------|-------|
| `rsqrt` | é«˜ | ä½ |
| `mul.Tensor` / `mul.Scalar` | é«˜ | ä½ |
| `silu` | é«˜ | ä½ |
| `cos` / `sin` | ä¸­ | ä½ |
| `pow.Tensor_Scalar` | ä¸­ | ä½ |
| `mean.dim` | ä¸­ | ä¸­ |

### ğŸŸ¡ P1: é‡è¦ä¼˜åŒ–

| ç®—å­ | é¢„æœŸæ€§èƒ½æå‡ | å¤æ‚åº¦ |
|-----|-------------|-------|
| `softmax` | é«˜ | ä¸­ |
| `scaled_dot_product_attention` | å¾ˆé«˜ï¼ˆèåˆç®—å­ï¼‰ | é«˜ |

### ğŸŸ¢ P2: å®Œæ•´æ€§

| ç®—å­ | è¯´æ˜ |
|-----|------|
| `embedding` | ä»…è¾“å…¥å±‚è°ƒç”¨ |
| `cat` | KV Cache æ“ä½œ |
| å…¶ä»–åŸºç¡€ç®—å­ | æŒ‰éœ€å®ç° |

---

## å¼€å‘è®¡åˆ’

### Phase 1: æ ¸å¿ƒçŸ©é˜µè¿ç®— âœ… å·²å®Œæˆ
- [x] MM (çŸ©é˜µä¹˜æ³•) - `echoNpuMatMul`
- [x] BMM (æ‰¹é‡çŸ©é˜µä¹˜æ³•) - `echoNpuBatchMatMul`
- [x] Add (å¼ é‡åŠ æ³•) - `echoNpuAddTensor`
- [x] æ˜¾å¼ Copy å†…å­˜æ¨¡å‹ - `echoNpuMemcpy` with direction

### Phase 2: RMSNorm åŸç”Ÿå®ç° â³ è¿›è¡Œä¸­
- [ ] `echoNpuRsqrt` - rsqrt
- [ ] `echoNpuPow` - pow
- [ ] `echoNpuMean` - mean.dim
- [ ] `echoNpuMulTensor` / `echoNpuMulScalar` - mul

### Phase 3: æ¿€æ´»å‡½æ•° & ä½ç½®ç¼–ç 
- [ ] `echoNpuSiLU` - silu æ¿€æ´»
- [ ] `echoNpuCos` / `echoNpuSin` - Rotary Embedding

### Phase 4: Attention ä¼˜åŒ–
- [ ] `echoNpuSoftmax` - softmax
- [ ] `echoNpuSDPA` - Scaled Dot-Product Attentionï¼ˆèåˆç®—å­ï¼‰

### Phase 5: å…¶ä»–ç®—å­ & æ€§èƒ½ä¼˜åŒ–
- [ ] Embedding
- [ ] çŸ©é˜µä¹˜æ³•æ€§èƒ½ä¼˜åŒ–ï¼ˆBLAS/ä¸“ç”¨åº“ï¼‰
- [ ] Caching Allocatorï¼ˆå¯é€‰ä¼˜åŒ–ï¼‰

### Phase 6: ğŸ”´ LoRA Finetune æ”¯æŒ ğŸš§ å¾…å¼€å‘ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
- [ ] å®ç°åå‘ä¼ æ’­åŸºç¡€ç®—å­ (Fallback æ–¹å¼)
- [ ] éªŒè¯ LeNet è®­ç»ƒæ­£ç¡®æ€§
- [ ] å®ç° LoRA å±‚ç®—å­
- [ ] éªŒè¯ Qwen LoRA å¾®è°ƒç«¯åˆ°ç«¯
- [ ] ä¼˜åŒ–å…³é”®åå‘ç®—å­ä¸º NPU åŸç”Ÿå®ç°

### Phase 7: CModel ç‰©ç†å†…å­˜æŠ½è±¡ ğŸš§ å¾…å¼€å‘
- [ ] è®¾è®¡ NPU ç‰©ç†åœ°å€ç©ºé—´å¸ƒå±€
- [ ] å®ç°ç‰©ç†åœ°å€åˆ†é…å™¨ (PhysicalMemoryAllocator)
- [ ] å®ç° RAM æ¨¡æ‹Ÿå™¨ (SimulatedRAM)
- [ ] ä¿®æ”¹ echoNpuMalloc/Free è¿”å›ç‰©ç†åœ°å€
- [ ] ä¿®æ”¹ echoNpuMemcpy æ”¯æŒç‰©ç†åœ°å€è®¿å­˜
- [ ] éªŒè¯ç°æœ‰ç®—å­åœ¨ç‰©ç†å†…å­˜æ¨¡å‹ä¸‹æ­£ç¡®æ€§

### Phase 8: RTL Model åç«¯ (Verilator) ğŸš§ å¾…å¼€å‘
- [ ] è®¾è®¡ AXI æ¥å£å°è£…
- [ ] å®šä¹‰å‘½ä»¤åŒ…æ ¼å¼ (NpuCommandPacket)
- [ ] å®ç° Verilator wrapper
- [ ] å®ç° RAM æ¨¡å‹æ¥å£
- [ ] é›†æˆ NPU RTL ä»£ç 
- [ ] éªŒè¯åŸºç¡€ç®—å­ (mm, add)

### Phase 9: ç¼–è¯‘åç«¯åˆ‡æ¢ ğŸš§ å¾…å¼€å‘
- [ ] é‡æ„ setup.py æ”¯æŒ ECHO_NPU_BACKEND ç¯å¢ƒå˜é‡
- [ ] æ·»åŠ  CMakeLists.txtï¼ˆå¯é€‰ï¼‰
- [ ] å®šä¹‰ Backend æŠ½è±¡æ¥å£ (backend_interface.h)
- [ ] é‡æ„ cmodel ä¸º CModelBackend
- [ ] é‡æ„ fpga ä¸º FPGABackend
- [ ] æ·»åŠ  rtlmodel åç«¯
- [ ] æ·»åŠ  asic åç«¯æ¡†æ¶

### Phase 10: Runtime æ¶æ„é‡æ„ ğŸš§ å¾…å¼€å‘
- [ ] å®šä¹‰ Backend æŠ½è±¡æ¥å£
- [ ] å®ç°åç«¯ç®¡ç†å™¨
- [ ] æ”¯æŒè¿è¡Œæ—¶åç«¯åˆ‡æ¢

---

## è°ƒè¯•å·¥å…·

### Debug è¾“å‡ºç³»ç»Ÿ

é€šè¿‡ç¯å¢ƒå˜é‡æ§åˆ¶è°ƒè¯•è¾“å‡ºçº§åˆ«ï¼š

```bash
# çº§åˆ« 1ï¼šæ˜¾ç¤ºç®—å­ç±»å‹
ECHO_NPU_DEBUG_LEVEL=1 python your_script.py

# çº§åˆ« 2ï¼šæ˜¾ç¤ºç®—å­ç±»å‹ + æ•°æ®ä¼ è¾“
ECHO_NPU_DEBUG_LEVEL=2 python your_script.py

# çº§åˆ« 3ï¼šæ˜¾ç¤ºç®—å­ç±»å‹ + æ•°æ®ä¼ è¾“ + Runtime è¯¦æƒ…
ECHO_NPU_DEBUG_LEVEL=3 python your_script.py
```

è¾“å‡ºæ ¼å¼ï¼š
- `[NPU]` (ç»¿è‰²) - NPU åŸç”Ÿå®ç°
- `[CPU]` (çº¢è‰²) - CPU Fallback
- `[COPY]` (è“è‰²) - æ•°æ®ä¼ è¾“ (Hâ†’D, Dâ†’H, Dâ†’D)
- `[VIEW]` (é’è‰²) - View æ“ä½œï¼ˆæ— æ•°æ®æ‹·è´ï¼‰

---

## æµ‹è¯•éªŒè¯

### å½“å‰æµ‹è¯•çŠ¶æ€

| æµ‹è¯•é¡¹ | çŠ¶æ€ | è¯´æ˜ |
|-------|------|------|
| åŸºç¡€ mm/bmm æµ‹è¯• | âœ… é€šè¿‡ | ç²¾åº¦è¯¯å·® < 1e-5 |
| Linear å±‚æµ‹è¯• | âœ… é€šè¿‡ | 768â†’3072 ç»´åº¦ |
| LeNet Forward | âœ… é€šè¿‡ | CPU vs NPU è¾“å‡ºå®Œå…¨ä¸€è‡´ |
| Qwen 0.5B Forward | âœ… é€šè¿‡ | å®Œæ•´å‰å‘ä¼ æ’­ |

### æµ‹è¯•å‘½ä»¤

```bash
# è¿è¡Œ LeNet æµ‹è¯•
python test/test_lenet.py

# è¿è¡Œ Qwen æ¨¡å‹æµ‹è¯•
python test/test_qwen0.5B.py

# è¿è¡Œè‡ªå®šä¹‰ç®—å­æµ‹è¯•
python test/test_custom_ops.py

# å¸¦è°ƒè¯•è¾“å‡ºè¿è¡Œ
ECHO_NPU_DEBUG_LEVEL=2 python test/test_lenet.py
```

---

## ç›¸å…³æ–‡ä»¶

| æ–‡ä»¶ | è¯´æ˜ |
|-----|------|
| `runtime/echo_npu_runtime.h` | Runtime API å£°æ˜ |
| `runtime/echo_npu_debug.h` | è°ƒè¯•ç³»ç»Ÿå¤´æ–‡ä»¶ |
| `runtime/cmodel/simulator.cpp` | cmodel CPU æ¨¡æ‹Ÿå®ç° |
| `runtime/fpga/simulator.cpp` | FPGA å®ç°ï¼ˆå¾…å®Œå–„ï¼‰ |
| `backend/echo_npu_ops.cpp` | PyTorch ç®—å­æ³¨å†Œ |
| `backend/echo_npu_allocator.cpp` | å†…å­˜åˆ†é…å™¨ |
| `echo_npu/debug.py` | Python è°ƒè¯•æ¥å£ |
| `test/test_qwen0.5B.py` | Qwen æ¨¡å‹æµ‹è¯• |
| `test/test_lenet.py` | LeNet æ¨¡å‹æµ‹è¯• |

---

## ğŸ”´ å¾…å¼€å‘ï¼šLoRA Finetune æ”¯æŒï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰

### éœ€æ±‚èƒŒæ™¯

å½“å‰ ECHO-NPU ä»…æ”¯æŒæ¨ç†ï¼ˆå‰å‘ä¼ æ’­ï¼‰ï¼Œè¦å®ç° LLM çš„ LoRA å¾®è°ƒï¼Œéœ€è¦æ”¯æŒï¼š

1. **åå‘ä¼ æ’­ï¼ˆBackwardï¼‰**ï¼šè®¡ç®—æ¢¯åº¦
2. **å‚æ•°æ›´æ–°ï¼ˆOptimizerï¼‰**ï¼šAdamW ç­‰ä¼˜åŒ–å™¨
3. **LoRA å±‚**ï¼šä½ç§©é€‚é…å™¨çš„é«˜æ•ˆè®¡ç®—

### è®­ç»ƒæ‰€éœ€ç®—å­åˆ†æ

#### åå‘ä¼ æ’­æ ¸å¿ƒç®—å­

| å‰å‘ç®—å­ | åå‘ç®—å­ | è¯´æ˜ | ä¼˜å…ˆçº§ |
|---------|---------|------|-------|
| `mm` | `mm` (è½¬ç½®) | âˆ‚L/âˆ‚A = âˆ‚L/âˆ‚C @ B^T, âˆ‚L/âˆ‚B = A^T @ âˆ‚L/âˆ‚C | ğŸ”´ P0 |
| `bmm` | `bmm` (è½¬ç½®) | åŒä¸Šï¼Œæ‰¹é‡ç‰ˆæœ¬ | ğŸ”´ P0 |
| `add` | `add` (identity) | æ¢¯åº¦ç›´æ¥ä¼ é€’ | ğŸ”´ P0 |
| `mul` | `mul` | âˆ‚L/âˆ‚A = âˆ‚L/âˆ‚C * B | ğŸ”´ P0 |
| `softmax` | `softmax_backward` | Jacobian è®¡ç®— | ğŸŸ¡ P1 |
| `silu` | `silu_backward` | Ïƒ(x) * (1 + x * (1 - Ïƒ(x))) | ğŸŸ¡ P1 |
| `rms_norm` | `rms_norm_backward` | å¤åˆæ¢¯åº¦ | ğŸŸ¡ P1 |

#### ä¼˜åŒ–å™¨ç®—å­

| ç®—å­ | ç”¨é€” | è¯´æ˜ |
|-----|------|------|
| `addcmul` | AdamW | m = Î²1 * m + (1-Î²1) * grad |
| `addcdiv` | AdamW | param -= lr * m / (sqrt(v) + eps) |
| `mul_` | æƒé‡è¡°å‡ | param *= (1 - lr * weight_decay) |
| `add_` | å‚æ•°æ›´æ–° | param += update |

#### LoRA ç‰¹å®šç®—å­

```
LoRA è®¡ç®—æµç¨‹ï¼š
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     åŸå§‹æƒé‡ W [d_out, d_in]         â”‚
                    â”‚         (å†»ç»“)                       â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      +
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LoRA å¢é‡ Î”W = B @ A                                           â”‚
â”‚                                                                 â”‚
â”‚  x â”€â”€â–¶ [A: rÃ—d_in] â”€â”€â–¶ [B: d_outÃ—r] â”€â”€â–¶ scale â”€â”€â–¶ Î”W @ x       â”‚
â”‚        (å¯è®­ç»ƒ)        (å¯è®­ç»ƒ)         Î±/r                     â”‚
â”‚                                                                 â”‚
â”‚  å…³é”®ç®—å­ï¼š                                                      â”‚
â”‚  - mm: A @ x, B @ (A @ x)                                       â”‚
â”‚  - scale: å¸¸æ•°ä¹˜æ³•                                               â”‚
â”‚  - add: W @ x + Î”W @ x                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å®ç°è·¯çº¿

```
Phase 6.1: åŸºç¡€è®­ç»ƒæ”¯æŒ
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â”œâ”€â”€ å®ç° backward ç®—å­æ¡†æ¶
â”œâ”€â”€ mm_backward (æœ€æ ¸å¿ƒ)
â”œâ”€â”€ add_backward
â””â”€â”€ éªŒè¯ LeNet è®­ç»ƒ

Phase 6.2: LLM è®­ç»ƒç®—å­
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â”œâ”€â”€ softmax_backward
â”œâ”€â”€ silu_backward
â”œâ”€â”€ rms_norm_backward
â””â”€â”€ éªŒè¯ Transformer block è®­ç»ƒ

Phase 6.3: ä¼˜åŒ–å™¨ & LoRA
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â”œâ”€â”€ AdamW ä¼˜åŒ–å™¨ç®—å­
â”œâ”€â”€ LoRA å±‚é«˜æ•ˆå®ç°
â”œâ”€â”€ æ··åˆç²¾åº¦æ”¯æŒ (å¯é€‰)
â””â”€â”€ Qwen LoRA ç«¯åˆ°ç«¯éªŒè¯

Phase 6.4: æ€§èƒ½ä¼˜åŒ–
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â”œâ”€â”€ æ¢¯åº¦ç´¯ç§¯
â”œâ”€â”€ æ¢¯åº¦æ£€æŸ¥ç‚¹
â”œâ”€â”€ ç®—å­èåˆ (Backward Fusion)
â””â”€â”€ å†…å­˜ä¼˜åŒ–
```

### éªŒè¯è®¡åˆ’

| é˜¶æ®µ | æµ‹è¯•é¡¹ | éªŒè¯å†…å®¹ |
|-----|-------|---------|
| 6.1 | LeNet Training | åŸºç¡€åå‘ä¼ æ’­æ­£ç¡®æ€§ |
| 6.2 | Transformer Block | Attention + FFN æ¢¯åº¦ |
| 6.3 | Qwen LoRA | ç«¯åˆ°ç«¯å¾®è°ƒï¼Œloss ä¸‹é™ |
| 6.4 | æ€§èƒ½æµ‹è¯• | è®­ç»ƒååé‡å¯¹æ¯” |

### é¢„æœŸæŒ‘æˆ˜

1. **å†…å­˜ç®¡ç†**ï¼šè®­ç»ƒéœ€è¦ä¿å­˜æ¿€æ´»å€¼ç”¨äºåå‘ä¼ æ’­ï¼Œå†…å­˜éœ€æ±‚å¢åŠ 
2. **æ•°å€¼ç²¾åº¦**ï¼šæ¢¯åº¦è®¡ç®—å¯¹ç²¾åº¦æ•æ„Ÿï¼Œéœ€è¦éªŒè¯ FP32 ç²¾åº¦
3. **æ€§èƒ½**ï¼šåå‘ä¼ æ’­è®¡ç®—é‡çº¦ä¸ºå‰å‘çš„ 2 å€

---

## å¾…å¼€å‘ï¼šCModel ç‰©ç†å†…å­˜æŠ½è±¡

### é—®é¢˜åˆ†æ

å½“å‰ CModel å®ç°ç›´æ¥ä½¿ç”¨ CPU çš„ `malloc`/`free` å’Œè™šæ‹Ÿåœ°å€ï¼š

```cpp
// å½“å‰å®ç° (runtime/cmodel/simulator.cpp)
EchoNpuError echoNpuMalloc(void** ptr, size_t size) {
    *ptr = malloc(size);  // â† è¿”å› CPU è™šæ‹Ÿåœ°å€
    return ECHO_NPU_SUCCESS;
}

EchoNpuError echoNpuMemcpy(void* dst, const void* src, size_t size, EchoNpuMemcpyKind kind) {
    memcpy(dst, src, size);  // â† ç›´æ¥ä½¿ç”¨ CPU memcpy
    return ECHO_NPU_SUCCESS;
}
```

**é—®é¢˜**ï¼š
1. æ— æ³•æ¨¡æ‹ŸçœŸå® NPU çš„ç‰©ç†å†…å­˜è¡Œä¸º
2. ä¸ RTL Model å’Œç¡¬ä»¶çš„å†…å­˜æ¨¡å‹ä¸ä¸€è‡´
3. æ— æ³•éªŒè¯åœ°å€å¯¹é½ã€å†…å­˜å¸ƒå±€ç­‰ç¡¬ä»¶çº¦æŸ

### ç›®æ ‡è®¾è®¡

#### ç‰©ç†åœ°å€ç©ºé—´å¸ƒå±€

```
NPU Physical Address Map (ç¤ºä¾‹ï¼Œå¯é…ç½®)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  0x0000_0000 - 0x0FFF_FFFF  â”‚  Weight Memory (256MB)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  0x1000_0000 - 0x1FFF_FFFF  â”‚  Activation Memory (256MB)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  0x2000_0000 - 0x2000_FFFF  â”‚  Register Space (64KB)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  0x2001_0000 - 0x3FFF_FFFF  â”‚  Reserved                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### æ ¸å¿ƒç»„ä»¶è®¾è®¡

```cpp
// runtime/memory/physical_memory.h

namespace echo_npu {

// NPU ç‰©ç†åœ°å€ç±»å‹
using PhysAddr = uint64_t;

// ç‰©ç†å†…å­˜é…ç½®
struct MemoryConfig {
    PhysAddr weight_base = 0x00000000;
    size_t weight_size = 256 * 1024 * 1024;  // 256MB
    PhysAddr activation_base = 0x10000000;
    size_t activation_size = 256 * 1024 * 1024;  // 256MB
    size_t alignment = 64;  // 64å­—èŠ‚å¯¹é½
};

// æ¨¡æ‹Ÿ RAM
class SimulatedRAM {
public:
    SimulatedRAM(size_t size);
    
    // ç‰©ç†åœ°å€è¯»å†™
    void write(PhysAddr addr, const void* data, size_t size);
    void read(PhysAddr addr, void* data, size_t size) const;
    
    // è·å–ç‰©ç†åœ°å€å¯¹åº”çš„ host æŒ‡é’ˆï¼ˆä»…ç”¨äºè°ƒè¯•ï¼‰
    void* getHostPtr(PhysAddr addr);
    
private:
    std::vector<uint8_t> memory_;
    PhysAddr base_addr_;
};

// ç‰©ç†åœ°å€åˆ†é…å™¨
class PhysicalMemoryAllocator {
public:
    PhysicalMemoryAllocator(const MemoryConfig& config);
    
    // åˆ†é…/é‡Šæ”¾ç‰©ç†åœ°å€
    PhysAddr allocate(size_t size, size_t alignment = 0);
    void free(PhysAddr addr);
    
    // æŸ¥è¯¢
    size_t getAllocatedSize() const;
    size_t getFreeSize() const;
    
private:
    // ç®€å•çš„ first-fit åˆ†é…å™¨ï¼Œåç»­å¯ä¼˜åŒ–
    struct Block { PhysAddr addr; size_t size; bool free; };
    std::vector<Block> blocks_;
};

// å†…å­˜ç®¡ç†å™¨ï¼ˆæ•´åˆåˆ†é…å™¨å’Œ RAMï¼‰
class MemoryManager {
public:
    static MemoryManager& instance();
    
    // åˆ†é… NPU å†…å­˜ï¼Œè¿”å›ç‰©ç†åœ°å€
    PhysAddr allocate(size_t size);
    void free(PhysAddr addr);
    
    // Host â†” Device æ•°æ®ä¼ è¾“
    void copyHostToDevice(PhysAddr dst, const void* src, size_t size);
    void copyDeviceToHost(void* dst, PhysAddr src, size_t size);
    void copyDeviceToDevice(PhysAddr dst, PhysAddr src, size_t size);
    
    // è·å– RAM å¼•ç”¨ï¼ˆä¾›ç®—å­å®ç°ä½¿ç”¨ï¼‰
    SimulatedRAM& getRAM();
    
private:
    MemoryConfig config_;
    SimulatedRAM ram_;
    PhysicalMemoryAllocator allocator_;
};

} // namespace echo_npu
```

#### ä¿®æ”¹åçš„ Runtime API å®ç°

```cpp
// runtime/cmodel/simulator.cpp (ä¿®æ”¹å)

EchoNpuError echoNpuMalloc(void** ptr, size_t size) {
    auto& mm = MemoryManager::instance();
    PhysAddr paddr = mm.allocate(size);
    if (paddr == 0) {
        return ECHO_NPU_ERROR_OUT_OF_MEMORY;
    }
    // è¿”å›ç‰©ç†åœ°å€ï¼ˆå¼ºåˆ¶è½¬æ¢ä¸ºæŒ‡é’ˆå½¢å¼ï¼Œè°ƒç”¨è€…éœ€çŸ¥é“è¿™æ˜¯ç‰©ç†åœ°å€ï¼‰
    *ptr = reinterpret_cast<void*>(paddr);
    return ECHO_NPU_SUCCESS;
}

EchoNpuError echoNpuMemcpy(void* dst, const void* src, size_t size, EchoNpuMemcpyKind kind) {
    auto& mm = MemoryManager::instance();
    
    switch (kind) {
        case ECHO_NPU_MEMCPY_HOST_TO_DEVICE:
            mm.copyHostToDevice(reinterpret_cast<PhysAddr>(dst), src, size);
            break;
        case ECHO_NPU_MEMCPY_DEVICE_TO_HOST:
            mm.copyDeviceToHost(const_cast<void*>(dst), 
                               reinterpret_cast<PhysAddr>(src), size);
            break;
        case ECHO_NPU_MEMCPY_DEVICE_TO_DEVICE:
            mm.copyDeviceToDevice(reinterpret_cast<PhysAddr>(dst),
                                  reinterpret_cast<PhysAddr>(src), size);
            break;
        // ...
    }
    return ECHO_NPU_SUCCESS;
}

// ç®—å­å®ç°éœ€è¦ä¿®æ”¹ä¸ºä½¿ç”¨ç‰©ç†åœ°å€è®¿å­˜
EchoNpuError echoNpuAddTensor(float* output, const float* input1,
                            const float* input2, size_t num_elements, float alpha) {
    auto& ram = MemoryManager::instance().getRAM();
    PhysAddr out_addr = reinterpret_cast<PhysAddr>(output);
    PhysAddr in1_addr = reinterpret_cast<PhysAddr>(input1);
    PhysAddr in2_addr = reinterpret_cast<PhysAddr>(input2);
    
    // é€šè¿‡ç‰©ç†åœ°å€è®¿é—® RAM
    for (size_t i = 0; i < num_elements; ++i) {
        float v1, v2, result;
        ram.read(in1_addr + i * sizeof(float), &v1, sizeof(float));
        ram.read(in2_addr + i * sizeof(float), &v2, sizeof(float));
        result = v1 + alpha * v2;
        ram.write(out_addr + i * sizeof(float), &result, sizeof(float));
    }
    return ECHO_NPU_SUCCESS;
}
```

### è¿ç§»è®¡åˆ’

1. **Phase 1**ï¼šå®ç° `SimulatedRAM` å’Œ `PhysicalMemoryAllocator`
2. **Phase 2**ï¼šå®ç° `MemoryManager`ï¼Œä¿®æ”¹ `echoNpuMalloc`/`echoNpuFree`
3. **Phase 3**ï¼šä¿®æ”¹ `echoNpuMemcpy` æ”¯æŒç‰©ç†åœ°å€
4. **Phase 4**ï¼šé€ä¸ªä¿®æ”¹ç®—å­å®ç°ä½¿ç”¨ç‰©ç†åœ°å€è®¿å­˜
5. **Phase 5**ï¼šéªŒè¯æ‰€æœ‰ç°æœ‰æµ‹è¯•é€šè¿‡

---

## å¾…å¼€å‘ï¼šRTL Model åç«¯ (Verilator)

### ç›®æ ‡

ä½¿ç”¨ Verilator å°† NPU IP çš„ Verilog/SystemVerilog RTL ä»£ç ç¼–è¯‘ä¸º C++ ä»¿çœŸæ¨¡å‹ï¼Œä½œä¸ºä¸€ä¸ªåç«¯å®ç°ã€‚

### æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PyTorch Backend Layer                                          â”‚
â”‚  echoNpuMatMul(), echoNpuAddTensor(), ...                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  RTL Model Backend (runtime/rtlmodel/)                          â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  RTLModelBackend : EchoNpuBackend                         â”‚   â”‚
â”‚  â”‚  - å®ç°æ‰€æœ‰ Runtime API                                   â”‚   â”‚
â”‚  â”‚  - å°† API è°ƒç”¨è½¬æ¢ä¸ºå‘½ä»¤åŒ…                                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                           â”‚                                     â”‚
â”‚                           â–¼                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  VerilatorWrapper                                        â”‚   â”‚
â”‚  â”‚  - ç®¡ç†ä»¿çœŸæ—¶é’Ÿ                                           â”‚   â”‚
â”‚  â”‚  - é©±åŠ¨ AXI æ¥å£                                         â”‚   â”‚
â”‚  â”‚  - å¤„ç†ä¸­æ–­/å®Œæˆä¿¡å·                                      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                           â”‚                                     â”‚
â”‚                           â–¼                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Verilator Generated (obj_dir/)                                 â”‚
â”‚  â”œâ”€ Vnpu_top.h           - é¡¶å±‚æ¨¡å—å¤´æ–‡ä»¶                       â”‚
â”‚  â”œâ”€ Vnpu_top.cpp         - ä»¿çœŸå®ç°                            â”‚
â”‚  â””â”€ Vnpu_top__ALL.a      - é™æ€åº“                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  NPU RTL (rtl/)                                                 â”‚
â”‚  â”œâ”€ npu_top.v            - é¡¶å±‚ (AXI Slave + Control)          â”‚
â”‚  â”œâ”€ axi_slave.v          - AXI4 Slave æ¥å£                     â”‚
â”‚  â”œâ”€ matrix_engine.v      - çŸ©é˜µè®¡ç®—å¼•æ“                         â”‚
â”‚  â”œâ”€ memory_controller.v  - å†…å­˜æ§åˆ¶å™¨                           â”‚
â”‚  â””â”€ ...                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å‘½ä»¤åŒ…è®¾è®¡

```cpp
// runtime/rtlmodel/command_packet.h

namespace echo_npu {

// æ“ä½œç å®šä¹‰
enum class NpuOpcode : uint32_t {
    NOP         = 0x00,
    MATMUL      = 0x01,  // çŸ©é˜µä¹˜æ³•
    ADD_TENSOR  = 0x02,  // å¼ é‡åŠ æ³•
    MEMCPY      = 0x03,  // å†…å­˜æ‹·è´
    SYNC        = 0xFF,  // åŒæ­¥
};

// å‘½ä»¤åŒ…ç»“æ„ï¼ˆå¯¹åº” RTL æ¥å£ï¼‰
struct alignas(64) NpuCommandPacket {
    uint32_t opcode;           // [31:0]  æ“ä½œç 
    uint32_t flags;            // [63:32] æ ‡å¿—ä½
    uint64_t src1_addr;        // æºåœ°å€1 (ç‰©ç†åœ°å€)
    uint64_t src2_addr;        // æºåœ°å€2 (ç‰©ç†åœ°å€)
    uint64_t dst_addr;         // ç›®æ ‡åœ°å€ (ç‰©ç†åœ°å€)
    uint32_t param[8];         // æ“ä½œå‚æ•°
    // param[0-1]: M (int64)
    // param[2-3]: K (int64)
    // param[4-5]: N (int64)
    // param[6]:   alpha (float, reinterpret)
    // param[7]:   reserved
};

// çŠ¶æ€å¯„å­˜å™¨
struct NpuStatus {
    uint32_t state;      // 0=IDLE, 1=BUSY, 2=DONE, 3=ERROR
    uint32_t error_code;
    uint64_t cycle_count;
};

} // namespace echo_npu
```

### AXI é©±åŠ¨å®ç°

```cpp
// runtime/rtlmodel/axi_driver.h

namespace echo_npu {

class AxiDriver {
public:
    AxiDriver(Vnpu_top* dut);
    
    // AXI4-Lite å¯„å­˜å™¨è®¿é—®
    void writeReg(uint32_t addr, uint32_t data);
    uint32_t readReg(uint32_t addr);
    
    // AXI4 å†…å­˜è®¿é—®
    void writeMem(uint64_t addr, const void* data, size_t size);
    void readMem(uint64_t addr, void* data, size_t size);
    
    // å‘½ä»¤æ¥å£
    void submitCommand(const NpuCommandPacket& cmd);
    void waitComplete(uint32_t timeout_cycles = 1000000);
    NpuStatus getStatus();
    
private:
    Vnpu_top* dut_;
    
    // AXI æ¡æ‰‹
    void axiWriteTransaction(uint64_t addr, const uint8_t* data, size_t len);
    void axiReadTransaction(uint64_t addr, uint8_t* data, size_t len);
    
    // æ—¶é’Ÿé©±åŠ¨
    void tick();
};

} // namespace echo_npu
```

### Verilator Wrapper

```cpp
// runtime/rtlmodel/verilator_wrapper.h

namespace echo_npu {

class VerilatorWrapper {
public:
    VerilatorWrapper();
    ~VerilatorWrapper();
    
    // åˆå§‹åŒ–/å¤ä½
    void reset(int cycles = 10);
    
    // æ—¶é’Ÿæ§åˆ¶
    void tick();
    void run(uint64_t cycles);
    
    // è·å– DUT å’Œé©±åŠ¨
    Vnpu_top* getDut() { return dut_.get(); }
    AxiDriver& getAxiDriver() { return *axi_driver_; }
    
    // RAM æ¨¡å‹
    SimulatedRAM& getRAM() { return ram_; }
    
    // ç»Ÿè®¡
    uint64_t getCycleCount() const { return cycle_count_; }
    
private:
    std::unique_ptr<Vnpu_top> dut_;
    std::unique_ptr<VerilatedVcdC> trace_;  // æ³¢å½¢è¿½è¸ªï¼ˆå¯é€‰ï¼‰
    std::unique_ptr<AxiDriver> axi_driver_;
    SimulatedRAM ram_;
    uint64_t cycle_count_ = 0;
};

} // namespace echo_npu
```

### RTL Model åç«¯å®ç°

```cpp
// runtime/rtlmodel/backend.cpp

class RTLModelBackend : public EchoNpuBackend {
public:
    const char* name() const override { return "rtlmodel"; }
    
    EchoNpuError matMul(float* output, const float* input1, const float* input2,
                       int64_t M, int64_t K, int64_t N) override {
        // 1. æ„é€ å‘½ä»¤åŒ…
        NpuCommandPacket cmd = {};
        cmd.opcode = static_cast<uint32_t>(NpuOpcode::MATMUL);
        cmd.src1_addr = reinterpret_cast<uint64_t>(input1);
        cmd.src2_addr = reinterpret_cast<uint64_t>(input2);
        cmd.dst_addr = reinterpret_cast<uint64_t>(output);
        memcpy(&cmd.param[0], &M, sizeof(int64_t));
        memcpy(&cmd.param[2], &K, sizeof(int64_t));
        memcpy(&cmd.param[4], &N, sizeof(int64_t));
        
        // 2. æäº¤å‘½ä»¤
        wrapper_.getAxiDriver().submitCommand(cmd);
        
        // 3. ç­‰å¾…å®Œæˆ
        wrapper_.getAxiDriver().waitComplete();
        
        // 4. æ£€æŸ¥çŠ¶æ€
        auto status = wrapper_.getAxiDriver().getStatus();
        if (status.state == 3) {  // ERROR
            return ECHO_NPU_ERROR_UNKNOWN;
        }
        
        return ECHO_NPU_SUCCESS;
    }
    
    // ... å…¶ä»–ç®—å­å®ç°ç±»ä¼¼
    
private:
    VerilatorWrapper wrapper_;
};
```

### æ„å»ºæµç¨‹

```bash
# 1. ç¼–è¯‘ RTL ä¸º Verilator æ¨¡å‹
verilator --cc --exe --build \
    -I rtl/ \
    rtl/npu_top.v \
    -o obj_dir/Vnpu_top

# 2. æ„å»º Python æ‰©å±•ï¼ˆåŒ…å« RTL Modelï¼‰
ECHO_NPU_BACKEND=rtlmodel python setup.py build_ext --inplace
```

### ç›®å½•ç»“æ„ï¼ˆæ–°å¢ï¼‰

```
runtime/
â”œâ”€â”€ rtlmodel/
â”‚   â”œâ”€â”€ backend.cpp           # RTLModelBackend å®ç°
â”‚   â”œâ”€â”€ backend.h
â”‚   â”œâ”€â”€ verilator_wrapper.cpp # Verilator å°è£…
â”‚   â”œâ”€â”€ verilator_wrapper.h
â”‚   â”œâ”€â”€ axi_driver.cpp        # AXI æ€»çº¿é©±åŠ¨
â”‚   â”œâ”€â”€ axi_driver.h
â”‚   â”œâ”€â”€ command_packet.h      # å‘½ä»¤åŒ…å®šä¹‰
â”‚   â””â”€â”€ Makefile.verilator    # Verilator æ„å»ºè„šæœ¬
â”œâ”€â”€ memory/
â”‚   â”œâ”€â”€ physical_memory.cpp   # ç‰©ç†å†…å­˜æ¨¡å‹
â”‚   â”œâ”€â”€ physical_memory.h
â”‚   â””â”€â”€ simulated_ram.cpp     # æ¨¡æ‹Ÿ RAM
â””â”€â”€ ...
```

---

## å¾…å¼€å‘ï¼šç¼–è¯‘åç«¯åˆ‡æ¢

### ç›®æ ‡

é€šè¿‡ç¯å¢ƒå˜é‡ `ECHO_NPU_BACKEND` åœ¨ç¼–è¯‘æ—¶é€‰æ‹©ä¸åŒçš„åç«¯å®ç°ã€‚

### setup.py æ”¹è¿›

```python
# setup.py

import os
from setuptools import setup
from torch.utils.cpp_extension import BuildExtension, CppExtension

# è¯»å–åç«¯é€‰æ‹©ï¼Œé»˜è®¤ cmodel
backend = os.environ.get('ECHO_NPU_BACKEND', 'cmodel')
valid_backends = ['cmodel', 'rtlmodel', 'fpga', 'asic']

if backend not in valid_backends:
    print(f"Warning: Invalid ECHO_NPU_BACKEND='{backend}', using 'cmodel'")
    backend = 'cmodel'

print(f"Building ECHO-NPU with backend: {backend}")

# é€šç”¨æºæ–‡ä»¶
common_sources = [
    'backend/echo_npu_allocator.cpp',
    'backend/echo_npu_guard.cpp',
    'backend/echo_npu_hooks.cpp',
    'backend/echo_npu_ops.cpp',
    'backend/echo_npu_module.cpp',
    'backend/echo_npu_custom_ops_example.cpp',
    'runtime/memory/physical_memory.cpp',  # æ–°å¢ï¼šç‰©ç†å†…å­˜æ¨¡å‹
]

# åç«¯ç‰¹å®šæºæ–‡ä»¶
backend_sources = {
    'cmodel': [
        'runtime/cmodel/backend.cpp',
    ],
    'rtlmodel': [
        'runtime/rtlmodel/backend.cpp',
        'runtime/rtlmodel/verilator_wrapper.cpp',
        'runtime/rtlmodel/axi_driver.cpp',
    ],
    'fpga': [
        'runtime/fpga/backend.cpp',
    ],
    'asic': [
        'runtime/asic/backend.cpp',
    ],
}

# åç«¯ç‰¹å®šç¼–è¯‘é€‰é¡¹
backend_compile_args = {
    'cmodel': [],
    'rtlmodel': ['-I/path/to/verilator/include'],  # Verilator å¤´æ–‡ä»¶
    'fpga': [],
    'asic': [],
}

# åç«¯ç‰¹å®šé“¾æ¥é€‰é¡¹
backend_link_args = {
    'cmodel': [],
    'rtlmodel': ['-L./obj_dir', '-lVnpu_top'],  # Verilator ç”Ÿæˆçš„åº“
    'fpga': [],
    'asic': [],
}

# åç«¯ç‰¹å®šå®å®šä¹‰
backend_define_macros = {
    'cmodel':   [('ECHO_NPU_BACKEND_CMODEL', '1')],
    'rtlmodel': [('ECHO_NPU_BACKEND_RTLMODEL', '1')],
    'fpga':     [('ECHO_NPU_BACKEND_FPGA', '1')],
    'asic':     [('ECHO_NPU_BACKEND_ASIC', '1')],
}

sources = common_sources + backend_sources[backend]

extra_compile_args = {
    'cxx': ['-std=c++17', '-O3', '-Wall'] + backend_compile_args[backend],
}

setup(
    name='echo_npu',
    version='0.1.0',
    ext_modules=[
        CppExtension(
            name='echo_npu._echo_npu_C',
            sources=sources,
            include_dirs=['.', 'backend', 'runtime'],
            extra_compile_args=extra_compile_args,
            extra_link_args=backend_link_args[backend],
            define_macros=backend_define_macros[backend],
        ),
    ],
    cmdclass={'build_ext': BuildExtension},
)
```

### ç¼–è¯‘å‘½ä»¤æ±‡æ€»

```bash
# CModel åç«¯ï¼ˆé»˜è®¤ï¼‰
python setup.py build_ext --inplace

# æˆ–æ˜¾å¼æŒ‡å®š
ECHO_NPU_BACKEND=cmodel python setup.py build_ext --inplace

# RTL Model åç«¯
# æ³¨æ„ï¼šéœ€è¦å…ˆç”¨ Verilator ç¼–è¯‘ RTL
cd runtime/rtlmodel && make -f Makefile.verilator && cd ../..
ECHO_NPU_BACKEND=rtlmodel python setup.py build_ext --inplace

# FPGA åç«¯
ECHO_NPU_BACKEND=fpga python setup.py build_ext --inplace

# ASIC åç«¯
ECHO_NPU_BACKEND=asic python setup.py build_ext --inplace
```

### è¿è¡Œæ—¶åç«¯æŸ¥è¯¢

```python
import echo_npu

# æŸ¥è¯¢å½“å‰åç«¯
print(echo_npu.get_backend_name())  # "cmodel" / "rtlmodel" / ...

# æŸ¥è¯¢åç«¯ä¿¡æ¯
print(echo_npu.get_backend_info())
# {
#     "name": "rtlmodel",
#     "version": "0.1.0",
#     "features": ["matmul", "add", "bmm"],
# }
```

---

## å¾…å¼€å‘ï¼šRuntime æ¶æ„é‡æ„

### é—®é¢˜åˆ†æ

å½“å‰ Runtime æ¶æ„å­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š

```
å½“å‰æ¶æ„ï¼ˆé—®é¢˜ï¼‰ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  runtime/echo_npu_runtime.h                                      â”‚
â”‚  - æ‰€æœ‰ API å£°æ˜ (echoNpuMalloc, echoNpuMatMul, ...)              â”‚
â”‚  - æ²¡æœ‰æŠ½è±¡å±‚ï¼Œç›´æ¥å£°æ˜å…·ä½“å‡½æ•°                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚ ç¼–è¯‘æ—¶é€‰æ‹©ä¸€ä¸ª
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼              â–¼              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ cmodel/        â”‚ â”‚ fpga/          â”‚ â”‚ asic/          â”‚
â”‚ simulator.cpp  â”‚ â”‚ simulator.cpp  â”‚ â”‚ (å¾…å®ç°)        â”‚
â”‚ ç›´æ¥å®ç°æ‰€æœ‰å‡½æ•° â”‚ â”‚ ç›´æ¥å®ç°æ‰€æœ‰å‡½æ•° â”‚ â”‚                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

é—®é¢˜ï¼š
1. ç¼–è¯‘æ—¶ç»‘å®šï¼Œæ— æ³•è¿è¡Œæ—¶åˆ‡æ¢åç«¯
2. æ¯ä¸ªåç«¯éœ€è¦å®Œæ•´å®ç°æ‰€æœ‰å‡½æ•°ï¼Œä»£ç é‡å¤
3. æ·»åŠ æ–°åç«¯éœ€è¦ä¿®æ”¹å¤šå¤„ä»£ç 
4. æµ‹è¯•å›°éš¾ï¼Œæ— æ³• mock åç«¯
```

### ç›®æ ‡æ¶æ„

```
ç›®æ ‡æ¶æ„ï¼ˆè§£è€¦ï¼‰ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  runtime/echo_npu_runtime.h                                      â”‚
â”‚  - å¯¹å¤–ç»Ÿä¸€æ¥å£ï¼ˆä¸å˜ï¼‰                                           â”‚
â”‚  - å†…éƒ¨å§”æ‰˜ç»™å½“å‰åç«¯                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  runtime/backend_interface.h  [NEW]                             â”‚
â”‚  - EchoNpuBackend æŠ½è±¡åŸºç±»                                        â”‚
â”‚  - çº¯è™šå‡½æ•°å®šä¹‰æ‰€æœ‰åç«¯éœ€è¦å®ç°çš„æ¥å£                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  runtime/backend_manager.h  [NEW]                               â”‚
â”‚  - åç«¯æ³¨å†Œè¡¨                                                    â”‚
â”‚  - è¿è¡Œæ—¶åç«¯é€‰æ‹© (getBackend(), setBackend())                   â”‚
â”‚  - é»˜è®¤åç«¯é…ç½®                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚ è¿è¡Œæ—¶é€‰æ‹©
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼              â–¼              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ cmodel/        â”‚ â”‚ fpga/          â”‚ â”‚ asic/          â”‚
â”‚ backend.cpp    â”‚ â”‚ backend.cpp    â”‚ â”‚ backend.cpp    â”‚
â”‚ CModelBackend  â”‚ â”‚ FPGABackend    â”‚ â”‚ ASICBackend    â”‚
â”‚ : EchoNpuBackendâ”‚ â”‚ : EchoNpuBackendâ”‚ â”‚ : EchoNpuBackendâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¥å£è®¾è®¡è‰æ¡ˆ

```cpp
// runtime/backend_interface.h
namespace echo_npu {

class EchoNpuBackend {
public:
    virtual ~EchoNpuBackend() = default;
    
    // åç«¯ä¿¡æ¯
    virtual const char* name() const = 0;
    virtual const char* version() const = 0;
    
    // è®¾å¤‡ç®¡ç†
    virtual EchoNpuError getDeviceCount(int* count) = 0;
    virtual EchoNpuError setDevice(int device) = 0;
    virtual EchoNpuError getDevice(int* device) = 0;
    
    // å†…å­˜ç®¡ç†
    virtual EchoNpuError malloc(void** ptr, size_t size) = 0;
    virtual EchoNpuError free(void* ptr) = 0;
    virtual EchoNpuError memcpy(void* dst, const void* src, 
                               size_t size, EchoNpuMemcpyKind kind) = 0;
    virtual EchoNpuError memset(void* ptr, int value, size_t size) = 0;
    
    // è®¡ç®—ç®—å­
    virtual EchoNpuError addTensor(float* output, const float* input1,
                                  const float* input2, size_t num_elements,
                                  float alpha = 1.0f) = 0;
    virtual EchoNpuError matMul(float* output, const float* input1,
                               const float* input2,
                               int64_t M, int64_t K, int64_t N) = 0;
    virtual EchoNpuError batchMatMul(float* output, const float* input1,
                                    const float* input2,
                                    int64_t B, int64_t M, int64_t K, int64_t N) = 0;
    // ... æ›´å¤šç®—å­
};

// åç«¯ç®¡ç†å™¨
class BackendManager {
public:
    static BackendManager& instance();
    
    void registerBackend(const std::string& name, 
                        std::unique_ptr<EchoNpuBackend> backend);
    EchoNpuBackend* getBackend(const std::string& name = "");
    void setDefaultBackend(const std::string& name);
    std::vector<std::string> listBackends() const;
    
private:
    std::unordered_map<std::string, std::unique_ptr<EchoNpuBackend>> backends_;
    std::string defaultBackend_ = "cmodel";
};

} // namespace echo_npu
```

### è¿ç§»è®¡åˆ’

1. **Phase 1**ï¼šåˆ›å»ºæ¥å£å®šä¹‰ï¼ˆä¸ç ´åç°æœ‰ä»£ç ï¼‰
2. **Phase 2**ï¼šå°† cmodel å®ç°é€‚é…ä¸º CModelBackend
3. **Phase 3**ï¼šå°† fpga å®ç°é€‚é…ä¸º FPGABackend
4. **Phase 4**ï¼šä¿®æ”¹ `echo_npu_runtime.h` ä½¿ç”¨åç«¯ç®¡ç†å™¨
5. **Phase 5**ï¼šæ·»åŠ  Python ç»‘å®šæ”¯æŒåç«¯åˆ‡æ¢
6. **Phase 6**ï¼šåˆ›å»º asic åç«¯æ¡†æ¶

---

## å¤‡æ³¨

1. **CPU Fallback æ˜¯ä¸´æ—¶æ–¹æ¡ˆ**ï¼šå½“å‰å¤§éƒ¨åˆ†ç®—å­ä½¿ç”¨ `cpu_fallback` æœºåˆ¶ï¼Œè¿™æ˜¯ä¸ºäº†å¿«é€ŸéªŒè¯åŠŸèƒ½æ­£ç¡®æ€§ï¼Œä¸æ˜¯æœ€ç»ˆæ–¹æ¡ˆã€‚

2. **æ€§èƒ½ä¼˜åŒ–çš„å…³é”®**ï¼šåœ¨ NPU Runtime å±‚åŸç”Ÿå®ç°ç®—å­ï¼Œæ¶ˆé™¤ CPU å¾€è¿”å’Œé¢‘ç¹çš„ malloc/free å¼€é”€ã€‚

3. **å†…å­˜æ•ˆç‡**ï¼šå½“ NPU åŸç”Ÿç®—å­å®Œå–„åï¼Œå¯è€ƒè™‘å®ç° Caching Allocator è¿›ä¸€æ­¥ä¼˜åŒ–å†…å­˜åˆ†é…ã€‚

4. **å¤šåç«¯æ”¯æŒ**ï¼šRuntime å±‚æ”¯æŒ cmodelï¼ˆè°ƒè¯•ï¼‰å’Œ fpga/asicï¼ˆç”Ÿäº§ï¼‰ä¸¤ç§å®ç°ï¼Œé€šè¿‡ç¼–è¯‘é€‰é¡¹åˆ‡æ¢ã€‚

5. **LoRA Finetune ä¼˜å…ˆ**ï¼šå½“å‰æœ€é«˜ä¼˜å…ˆçº§æ˜¯å®ç° LoRA Finetune æ”¯æŒï¼Œä»¥éªŒè¯è®­ç»ƒåŠŸèƒ½ã€‚æ¶æ„é‡æ„å’Œå…¶ä»–ä¼˜åŒ–å¯ä»¥åœ¨æ­¤ä¹‹åè¿›è¡Œã€‚
